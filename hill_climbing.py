# -*- coding: utf-8 -*-
"""Hill_Climbing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HwUzTFks0R_SD46uTYKCv_JkHO20creC
"""

import copy

def exists(i, j):
    # Checks if square exists within boundary
    return (i >= 0 and i < 8 and j >= 0 and j < 8)

def contains(i, j, l, m, queen_pairs):
    # Check if the two pair of queens have already been included in count
    if ((i, j, l, m) in queen_pairs) or ((l, m, i, j) in queen_pairs):
        return True
    return False

def position_queens_row_wise(board):

    """Place a single queen on every row. If there are more than

    two quueens in one row, it places them on other rows"""

    for row in board:
        while row.count(1) > 1:
            # More than one 1s so distribute to other rows
            for i in range(8):
                if board[i].count(1) == 0:
                    j = row.index(1)
                    board[i][j] = 1
                    row[j] = 0
                    break

    return board

def heuristic_value(board):

    # Calculates the heuristic value h of the current state of board

    # Number of pairs of queens attacking each other directly or indirectly
    h = 0
    queen_pairs = []
    for i in range(8):
        for j in range(8):
            if board[i][j]:
                # Calculate horizontal attacks
                for k in range(8):
                    if board[i][k] == 1 and k != j and not contains(i, j, i, k, queen_pairs):
                        queen_pairs.append((i, j, i, k))
                        h += 1
                # Calculate vertical attacks
                for k in range(8):
                    if board[k][j] == 1 and i != k and not contains(i, j, k, j, queen_pairs):
                        queen_pairs.append((i, j, k, j))
                        h += 1
                # Calculate / diagonal attacks
                # First go up the diagonal
                l, m = i-1, j+1
                while exists(l, m):
                    if board[l][m] == 1 and not contains(i, j, l, m, queen_pairs):
                        queen_pairs.append((i, j, l, m))
                        h += 1
                    l, m = l-1, m+1
                # Now go down the diagonal
                l, m = i+1, j-1
                while exists(l, m):
                    if board[l][m] == 1 and not contains(i, j, l, m, queen_pairs):
                        queen_pairs.append((i, j, l, m))
                        h += 1
                    l, m = l+1, m-1
                # Calculate \ diagonal attacks

                # First go up the diagonal
                l, m = i-1, j-1
                while exists(l, m):
                    if board[l][m] == 1 and not contains(i, j, l, m, queen_pairs):
                        queen_pairs.append((i, j, l, m))
                        h += 1
                    l, m = l-1, m-1
                # Now go down the diagonal
                l, m = i+1, j+1
                while exists(l, m):
                    if board[l][m] == 1 and not contains(i, j, l, m, queen_pairs):
                        queen_pairs.append((i, j, l, m))
                        h += 1
                    l, m = l+1, m+1

    return h

def hill_climbing(board):

    # Find the least cost successor for the given board state
    min_board = board
    min_h = 999999
    global n_side_moves, n_steps
    n_steps += 1
    # Check if number of side moves has reached a limit
    if n_side_moves == 100:
        return -1
    sideway_move = False
    for i in range(8):
        # Find index of queen in current row
        queen = board[i].index(1)
        board[i][queen] = 0
        for k in range(8):
            # Place queen at different positions and calculate new score
            if k != queen:
                board[i][k] = 1
                h = heuristic_value(board)
                if h < min_h:
                    min_h = h
                    min_board = copy.deepcopy(board)
                if h == min_h:
                    min_h = h
                    min_board = copy.deepcopy(board)
                    sideway_move = True
                board[i][k] = 0
        board[i][queen] = 1
    if sideway_move:
        n_side_moves += 1
    if min_h == 0:
        print("Number of steps required: {}".format(n_steps))
        return min_board
    for b in min_board:
        print(b,"\n")
    print("\n")    
    return hill_climbing(min_board)

if __name__ == "__main__":

    # 8x8 chess board
    board = []
    n_side_moves = 0
    n_steps = 0
    for i in range(8):
        row = list(map(int, input().split()))
        board.append(row)
    print("Current position's heuristic value: ", heuristic_value(board))
    board = position_queens_row_wise(board)
    min_board = hill_climbing(board)
    if min_board != -1:
        for b in min_board:
            print(b,"\n")
    else:
        print("Could not solve")

# from _future_ import print_function
import random

#initial state
chess_board = [0, 0, 0, 0, 0, 0, 0, 0]
initial_chess_board = chess_board

#function to print current state of the chess_board
def show_chess_board(chess_board_p):

    new_chess_board = []
    for i in range(len(chess_board)):
        new_chess_board.append([i, chess_board_p[i]])

    print(new_chess_board)

    for i in range(len(chess_board)):
        for j in range(len(chess_board)):
            if [j, i] in new_chess_board:
                print("Q", end=" ")
            else:
                print("*", end=" ")
        print()
    print()

#heuristic cost = no of queens attacking one another
#function to determine the heuristic cost of the chess_board
def determine_heuristic_cost(chess_board):
    h = 0

    # check all queens
    for i in range(len(chess_board)):
        # check interaction with remaining queens
        for j in range(i + 1, len(chess_board)):
            # if queen in same column
            if chess_board[i] == chess_board[j]:
                h += 1

            # get offset
            offset = i - j

            # check if there is diagonal interaction
            if chess_board[i] == chess_board[j] + offset or chess_board[i] == chess_board[j] - offset:
                h += 1
    return h

#there are 56(8*7) neighbouring states
#function to determine the next best move based on the h cost of all neighbouring states
def best_move(chess_board):
    moves = []
    moves.append([chess_board, determine_heuristic_cost(chess_board)])

    for col in range(len(chess_board)):
        for row in range(len(chess_board)):
            chess_board_copy = list(chess_board)
            if chess_board[col] == row:
                continue
            chess_board_copy[col] = row
            cost_of_state = determine_heuristic_cost(chess_board_copy)
            moves.append([chess_board_copy, cost_of_state])

    current = determine_heuristic_cost(chess_board)

    for row in moves:
        if row[1] < current:
            current = row[1]

    #there can be more than 1 best neighbouring state due to same h values
    best_moves = []
    for row in moves:
        if row[1] == current:
            best_moves.append(row[0])

    #randomly select one move out of all the best moves
    next_move = random.choice(best_moves)

    return next_move

#show initial state of the chess_board and its h cost
show_chess_board(chess_board)
print("h = " + str(determine_heuristic_cost(chess_board)))
print()

action_sequence = []

heuristic_cost = determine_heuristic_cost(chess_board)
action_sequence.append([chess_board, heuristic_cost])

#loop through until the minimum h cost state is achieved
no_of_steps = 0
state = 1
while (state == 1):

    chess_board_next_state = best_move(chess_board)

    #if the next best state is the current state, it has reached a maximum state
    if chess_board == chess_board_next_state or heuristic_cost == determine_heuristic_cost(chess_board_next_state):
        state = 0
        show_chess_board(chess_board)
        cost = determine_heuristic_cost(chess_board)
        print("h = " + str(cost))
        if cost == 0:
            print("Reached the Global Maximum!")
            print()
        else:
            print("Stuck in a Local Maximum")
            print()

            # if the result is a local minimum, then reinitialize the chess_board and try again
            state = 1
            chess_board = initial_chess_board
    else:
        chess_board = chess_board_next_state
        state = 1
        heuristic_cost = determine_heuristic_cost(chess_board)
        action_sequence.append([chess_board, heuristic_cost])
        no_of_steps += 1
        # show_chess_board(chess_board)

print("Steps taken: ")
for row in action_sequence:
    print(row)

print()
print("No.of steps: " + str(no_of_steps))
print()

print("The Final solution for 8-Queen Problem:")
print()
show_chess_board(chess_board)